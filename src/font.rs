use std::{array::IntoIter, collections::HashMap};

use sdl2::{rect::Point, render::Canvas, video::Window};

pub fn print(canvas: &mut Canvas<Window>, x: i32, y: i32, value: &str) -> Result<(), String> {
    let mut x = x;
    for char in value.chars() {
        let char_data = CHAR_DATA
            .get(&char)
            .or_else(|| CHAR_DATA.get(&'?'))
            .unwrap();
        char_data.draw(canvas, x, y)?;
        x += if char_data.long { 8 } else { 4 };
    }

    Ok(())
}

struct CharData {
    coords: Vec<(u8, u8)>,
    long: bool, // Two sizes: 3 or 7
}

impl CharData {
    fn draw(&self, canvas: &mut Canvas<Window>, x: i32, y: i32) -> Result<(), String> {
        for (cx, cy) in &self.coords {
            canvas.draw_point(Point::new(x + (*cx as i32), y + (*cy as i32)))?;
        }

        Ok(())
    }
}

// https://www.lexaloffle.com/bbs/?tid=3760
lazy_static::lazy_static! {
  static ref CHAR_DATA: HashMap<char, CharData> = HashMap::<_, _>::from_iter(
    IntoIter::new([
      (' ', ""),
      ('!', "
 #
 #
 #

 #"),
      ('"', "
# #
# #"),
('#', "
# #
###
# #
###
# #"),
('$', "
###
##
 ##
###
 # "),
('%', "
# #
  #
 # 
#  
# #"),
('&', "
## 
## 
## 
# #
###"),
('\'', "
  #
 #"),
('(', "
 #
#
#
#
 #"),
(')', "
 #
  #
  #
  #
 #"),
('*', "
# #
 #
###
 #
# #"),
('+', "
 
 #
###
 #"),
(',', "
 
 
 
  #
 #"),
('-', "
 
 
###"),
('.', "
 
 
 
 
 #"),
('/', "
  #
 #
 #
 #
#"),
('0', "
###
# #
# #
# #
###"),
('1', "
##
 #
 #
 #
###"),
('2', "
###
  #
###
#
###"),
('3', "
###
  #
 ##
  #
###"),
('4', "
# #
# #
###
  #
  #"),
('5', "
###
#
###
  #
###"),
('6', "
#
#
###
# #
###"),
('7', "
###
  #
  #
  #
  #"),
('8', "
###
# #
###
# #
###"),
('9', "
###
# #
###
  #
  #"),
(':', "
 
 #

 #"),
(';', "
 
 #

 #
#"),
('<', "
  #
 #
#
 #
  #"),
('=', "
 
###

###
"),
('>', "
#
 #
  #
 #
#"),
('?', "
###
#
##

#"),
('@', "
 #
# #
# #
#
 ##"),
('a', "
###
# #
###
# #
# #"),
('b', "
###
# #
##
# #
###"),
('c', "
 ##
#
#
#
 ##"),
('d', "
##
# #
# #
# #
###"),
('e', "
###
#
##
#
###"),
('f', "
###
#
##
#
#"),
('g', "
 ##
#
#
# #
###"),
('h', "
# #
# #
###
# #
# #"),
('i', "
###
 #
 #
 #
###"),
('j', "
###
 #
 #
 #
##"),
('k', "
# #
# #
##
# #
# #"),
('l', "
#
#
#
#
###"),
('m', "
###
###
# #
# #
# #"),
('n', "
##
# #
# #
# #
# #"),
('o', "
 ##
# #
# #
# #
##"),
('p', "
###
# #
###
#
#"),
('q', "
 #
# #
# #
##
 ##"),
('r', "
###
# #
##
# #
# #"),
('s', "
 ##
#
###
  #
##"),
('t', "
###
 #
 #
 #
 #"),
('u', "
# #
# #
# #
# #
 ##"),
('v', "
# #
# #
# #
###
 #"),
('w', "
# #
# #
# #
###
###"),
('x', "
# #
# #
 #
# #
# #"),
('y', "
# #
# #
###
  #
###"),
('z', "
###
  #
 #
#
###"),

('A', "
 
###
# #
###
# #"),
('B', "
 
##
##
# #
###"),
('C', "
 
###
#
#
###"),
('D', "
 
##
# #
# #
##"),
('E', "
 
###
##
#
###"),
('F', "
 
###
##
#
#"),
('G', "
 
###
#
# #
###"),
('H', "
 
# #
# #
###
# #"),
('I', "
 
###
 #
 #
###"),
('J', "
 
###
 #
 #
##"),
('K', "
 
# #
##
# #
# #"),
('L', "
 
#
#
#
###"),
('M', "
 
###
###
# #
# #"),
('N', "
 
##
# #
# #
# #"),
('O', "
 
 ##
# #
# #
##"),
('P', "
 
###
# #
###
#"),
('Q', "
 
 #
# #
##
 ##"),
('R', "
 
###
# #
##
# #"),
('S', "
 
 ##
#
  #
##"),
('T', "
 
###
 #
 #
 #"),
('U', "
 
# #
# #
# #
 ##"),
('V', "
 
# #
# #
###
 #"),
('W', "
 
# #
# #
###
###"),
('X', "
 
# #
 #
# #
# #"),
('Y', "
 
# #
###
  #
###"),
('Z', "
 
###
  #
#
###"),
('[', "
###
#
#
#
###"),
('\\', "
#
 #
 #
 #
  #"),
(']', "
###
  #
  #
  #
###"),
('^', "
 #
# #"),
('_', "
 
 
 
 
###"),
('`', "
 #
  #
"),
('a', "
###
# #
###
# #
# #"),
('b', "
###
# #
##
# #
###"),
('c', "
 ##
#
#
#
 ##"),
('d', "
##
# #
# #
# #
###"),
('e', "
###
#
##
#
###"),
('f', "
###
#
##
#
#"),
('g', "
 ##
#
#
# #
###"),
('h', "
# #
# #
###
# #
# #"),
('i', "
###
 #
 #
 #
###"),
('j', "
###
 #
 #
 #
##"),
('k', "
# #
# #
##
# #
# #"),
('l', "
#
#
#
#
###"),
('m', "
###
###
# #
# #
# #"),
('n', "
##
# #
# #
# #
# #"),
('o', "
 ##
# #
# #
# #
##"),
('p', "
###
# #
###
#
#"),
('q', "
 #
# #
# #
##
 ##"),
('r', "
###
# #
##
# #
# #"),
('s', "
 ##
#
###
  #
##"),
('t', "
###
 #
 #
 #
 #"),
('u', "
# #
# #
# #
# #
 ##"),
('v', "
# #
# #
# #
###
 #"),
('w', "
# #
# #
# #
###
###"),
('x', "
# #
# #
 #
# #
# #"),
('y', "
# #
# #
###
  #
###"),
('z', "
###
  #
 #
#
###"),
('{', "
 ##
 #
##
 #
 ##"),
('|', "
 #
 #
 #
 #
 #"),
('}', "
##
 #
 ##
 #
##"),
('~', "
 
  #
###
#
"),
// ??
('Ã±', "
 
 #
# #
# #
###"),
    ]).map(|(char, data)| (char, parse_char(data)))
  );
}

fn parse_char(value: &str) -> CharData {
    let lines = value.split("\n");
    let coords: Vec<(u8, u8)> = lines
        .skip_while(|v| v.len() == 0)
        .enumerate()
        .filter(|(_, v)| v.len() > 0)
        .flat_map(|(y, line)| {
            line.split("")
                .skip(1)
                .enumerate()
                .filter(|(_, v)| *v == "#")
                .map(move |(x, _)| (x as u8, y as u8))
        })
        .collect();

    let long = coords.iter().any(|(x, _)| *x > 3);
    CharData { coords, long }
}
