use sdl2::{rect::Point, render::Canvas, video::Window};
use std::{array::IntoIter, collections::HashMap};
use unicode_segmentation::UnicodeSegmentation;

pub fn print(canvas: &mut Canvas<Window>, x: i32, y: i32, value: &str) -> Result<(), String> {
    let mut x = x;
    for char in UnicodeSegmentation::graphemes(value, true) {
        let char_data = CHAR_DATA.get(&char).or_else(|| CHAR_DATA.get("?")).unwrap();
        char_data.draw(canvas, x, y)?;
        x += if char_data.long { 8 } else { 4 };
    }

    Ok(())
}

struct CharData {
    coords: Vec<(u8, u8)>,
    long: bool, // Two sizes: 3 or 7
}

impl CharData {
    fn draw(&self, canvas: &mut Canvas<Window>, x: i32, y: i32) -> Result<(), String> {
        for (cx, cy) in &self.coords {
            canvas.draw_point(Point::new(x + (*cx as i32), y + (*cy as i32)))?;
        }

        Ok(())
    }
}

// https://www.lexaloffle.com/bbs/?tid=3760
// TODO https://pico-8.fandom.com/wiki/P8SCII
lazy_static::lazy_static! {
  static ref CHAR_DATA: HashMap<&'static str, CharData> = HashMap::<_, _>::from_iter(
    IntoIter::new([
(" ", ""),
("!", "
 #
 #
 #

 #"),
("\"", "
# #
# #"),
("#", "
# #
###
# #
###
# #"),
("$", "
###
##
 ##
###
 # "),
("%", "
# #
  #
 # 
#  
# #"),
("&", "
##
##
 ##
# #
###"),
("\'", "
  #
 #"),
("(", "
 #
#
#
#
 #"),
(")", "
 #
  #
  #
  #
 #"),
("*", "
# #
 #
###
 #
# #"),
("+", "
 
 #
###
 #"),
(",", "
 
 
 
  #
 #"),
("-", "
 
 
###"),
(".", "
 
 
 
 
 #"),
("/", "
  #
 #
 #
 #
#"),
("0", "
###
# #
# #
# #
###"),
("1", "
##
 #
 #
 #
###"),
("2", "
###
  #
###
#
###"),
("3", "
###
  #
 ##
  #
###"),
("4", "
# #
# #
###
  #
  #"),
("5", "
###
#
###
  #
###"),
("6", "
#
#
###
# #
###"),
("7", "
###
  #
  #
  #
  #"),
("8", "
###
# #
###
# #
###"),
("9", "
###
# #
###
  #
  #"),
(":", "
 
 #

 #"),
(";", "
 
 #

 #
#"),
("<", "
  #
 #
#
 #
  #"),
("=", "
 
###

###
"),
(">", "
#
 #
  #
 #
#"),
("?", "
###
  #
 ##

 #"),
("@", "
 #
# #
# #
#
 ##"),

("A", "
 
 ##
# #
###
# #"),
("B", "
 
##
##
# #
###"),
("C", "
 
###
#
#
###"),
("D", "
 
##
# #
# #
##"),
("E", "
 
###
##
#
 ##"),
("F", "
 
###
##
#
#"),
("G", "
 
###
#
# #
###"),
("H", "
 
# #
# #
###
# #"),
("I", "
 
###
 #
 #
###"),
("J", "
 
###
 #
 #
##"),
("K", "
 
# #
##
# #
# #"),
("L", "
 
#
#
#
 ##"),
("M", "
 
###
###
# #
# #"),
("N", "
 
##
# #
# #
# #"),
("O", "
 
 ##
# #
# #
##"),
("P", "
 
###
# #
###
#"),
("Q", "
 
 #
# #
##
 ##"),
("R", "
 
###
# #
##
# #"),
("S", "
 
 ##
#
  #
##"),
("T", "
 
###
 #
 #
 #"),
("U", "
 
# #
# #
# #
 ##"),
("V", "
 
# #
# #
###
 #"),
("W", "
 
# #
# #
###
###"),
("X", "
 
# #
 #
# #
# #"),
("Y", "
 
# #
###
  #
###"),
("Z", "
 
###
  #
#
 ##"),
("[", "
###
#
#
#
###"),
("\\", "
#
 #
 #
 #
  #"),
("]", "
###
  #
  #
  #
###"),
("^", "
 #
# #"),
("_", "
 
 
 
 
###"),
("`", "
 #
  #
"),
("a", "
###
# #
###
# #
# #"),
("b", "
###
# #
##
# #
###"),
("c", "
 ##
#
#
#
 ##"),
("d", "
##
# #
# #
# #
###"),
("e", "
###
#
##
#
###"),
("f", "
###
#
##
#
#"),
("g", "
 ##
#
#
# #
###"),
("h", "
# #
# #
###
# #
# #"),
("i", "
###
 #
 #
 #
###"),
("j", "
###
 #
 #
 #
##"),
("k", "
# #
# #
##
# #
# #"),
("l", "
#
#
#
#
###"),
("m", "
###
###
# #
# #
# #"),
("n", "
##
# #
# #
# #
# #"),
("o", "
 ##
# #
# #
# #
##"),
("p", "
###
# #
###
#
#"),
("q", "
 #
# #
# #
##
 ##"),
("r", "
###
# #
##
# #
# #"),
("s", "
 ##
#
###
  #
##"),
("t", "
###
 #
 #
 #
 #"),
("u", "
# #
# #
# #
# #
 ##"),
("v", "
# #
# #
# #
###
 #"),
("w", "
# #
# #
# #
###
###"),
("x", "
# #
# #
 #
# #
# #"),
("y", "
# #
# #
###
  #
###"),
("z", "
###
  #
 #
#
###"),
("{", "
 ##
 #
##
 #
 ##"),
("|", "
 #
 #
 #
 #
 #"),
("}", "
##
 #
 ##
 #
##"),
("~", "
 
  #
###
#
"),
// ??
("Ã±", "
 
 #
# #
# #
###"),
// Large ones ///
// ??
("â€¦", "
 
 
# # # #
"),
("Ë‡", "
 
# #
 #  # #
     #
"),
("âˆ§", "
 
#   #
 # # #
  #   #
"),
("âŒ‚", "
  ###
 #####
#######
 # # #
 # ###"),
("â–ˆ", "
#######
#######
#######
#######
#######"),
("â–‘", "
#   #
  #   #
#   #
  #   #
#   #"),
("â–’", "
# # # #
 # # #
# # # #
 # # #
# # # #"),
("â–¤", "
#######

#######

#######"),
("â–¥", "
# # # #
# # # #
# # # #
# # # #
# # # #"),
("â—†", "
   #
  ###
 #####
  ###
   #"),
("â—", "
  ###
 ### #
 #####
 #####
  ###"),
("â˜‰", "
  ###
 ## ##
### ###
 ## ##
  ###"),
("â™¥", "
 ## ##
 #####
 #####
  ###
   #"),
("â™ª", "
   ###
   #
   #
 ###
 ###"),
("âœ½", "
  #
  ####
  ###
 ####
    #"),
("âŽ", "
 #####
## # ##
### ###
## # ##
 #####"),
("âž¡ï¸", "
 #####
##  ###
##   ##
##  ###
 #####"),
("â§—", "
 #####
  ###
   #
  ###
 #####"),
("â¬…ï¸", "
 #####
###  ##
##   ##
###  ##
 #####"),
("â¬†ï¸", "
 #####
### ###
##   ##
##   ##
 #####"),
("â¬‡ï¸", "
 #####
##   ##
##   ##
### ###
 #####"),
("ðŸ±", "
#     #
#######
# ### #
# ### #
 #####"),
("ðŸ˜", "
#######
# ### #
#######
#     #
#######"),
("ðŸ…¾ï¸", "
 #####
##   ##
## # ##
##   ##
 #####"),
("ì›ƒ", "
  ###
  ###
 #####
  ###
  # #"),
    ]).map(|(char, data)| (char, parse_char(data)))
  );
}

fn parse_char(value: &str) -> CharData {
    let lines = value.split("\n");
    let coords: Vec<(u8, u8)> = lines
        .skip_while(|v| v.len() == 0)
        .enumerate()
        .filter(|(_, v)| v.len() > 0)
        .flat_map(|(y, line)| {
            line.split("")
                .skip(1)
                .enumerate()
                .filter(|(_, v)| *v == "#")
                .map(move |(x, _)| (x as u8, y as u8))
        })
        .collect();

    let long = coords.iter().any(|(x, _)| *x > 3);
    CharData { coords, long }
}
